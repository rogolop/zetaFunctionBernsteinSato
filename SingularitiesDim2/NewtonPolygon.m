// Hack to return 0 when 0 * Infinity() is computed.
MyProd := function(a, b)
  if a eq 0 or b eq 0 then return 0;
  else return a * b; end if;
end function;

// Counter clockwise turn.
CcwTurn := function(p1, p2, p3)
  return (MyProd(p2[1] - p1[1], p3[2] - p1[2]) -
          MyProd(p2[2] - p1[2], p3[1] - p1[1])) le 0;
end function;

// Magma's NewtonPolygon function does not work in our case.
intrinsic NewtonPolygon(f::RngMPolLocElt) -> SeqEnum
{ The newton polygon for the bivariate polynomial f. }
require Rank(Parent(f)) eq 2: "Argument must be a bivariate polynomial";

  NP := [];
  for p in Sort([Exponents(m) : m in Monomials(f)]) cat [[Infinity(), 0]] do
    while #NP ge 2 and CcwTurn(NP[#NP - 1], NP[#NP], p) do
      Prune(~NP);
    end while; NP cat:= [p];
  end for; Prune(~NP); return NP;
end intrinsic;

NewtonSide := procedure(p, q, ~f, ~S)
  g := Gcd(p[2] - q[2], q[1] - p[1]);
  n := (p[2] - q[2]) div g;
  m := (q[1] - p[1]) div g;
  k := (p[2] * q[1] - p[1] * q[2]) div g;

  // Select which exponents are on the side generated by p & q.
  Q<X, Y> := PolynomialRing(IntegerRing(), 2);
  side := n * X + m * Y - k;
  C, M := CoefficientsAndMonomials(f);
  onSide := [C[i] * M[i] : i in [1..#M] |
    Evaluate(side, <Exponents(M[i])[1], Exponents(M[i])[2]>) eq 0];

  // Construct the equation associated with the pq side.
  P<Z> := PolynomialRing(CoefficientRing(Parent(f)));
  h := Evaluate(&+onSide, <1, Z>);
  E, _ := Support(h); C := Coefficients(h);
  beta0 := Reverse(Sort([Exponents(m) : m in onSide]))[1][2];
  S cat:= [<n, m, &+[C[e + 1] * Z^((e - beta0) div n) : e in E]>];
end procedure;

intrinsic NewtonSides(f::RngMPolLocElt, NP::SeqEnum) -> SeqEnum
{ Returns the sides of the Newton polygon. }
require Rank(Parent(f)) eq 2: "Argument must be a bivariate polynomial";

  S := [];
  for i in [1..#NP-1] do
    NewtonSide(NP[i], NP[i+1], ~f, ~S);
  end for; return S;
end intrinsic;
